//"строка", "последовательность" - тут одно и то же ("подпоследовательность" не математическом смысле, а в смысле "подстрока")
//все это корректно лишь для таких последовательностей, которые биективны натуральной последовательность (то есть без повторений,
//с нужным колчиством чисел, без выходов за границы [1, N])

В предложенной системе мы можем выполнять следующие преобразования:
1) Разбивать строку на любое число непересекающихся подстрок (пример: str_init = substr1 + substr2 + substr3)
2) Последовательно "заходить" этими строками на станцию
3) Выходить со станции в обратно порядке, меняя порядок самих строк и порядок внутри строк
Тогда итоговая строка будет иметь вид str_fin = substr3_inv + substr2_inv + substr1_inv (назовем это преобразованием [1])
То есть порядок подстрок меняется на обратный, как и порядок символов в них (то есть инвертируем эти подстроки и их порядок)

В частности мы можем выбрать такое разбиение, что, например, substr2 будет разбита на N подстрок (где N = subsrt2.length() ), 
тогда эти "элементарные" подстроки из одного символа буду невосприимчивы к инверсии внутри себя, что эквивалентно преобразованию [1],
модифицированному таким образом, что, например, вторая подстрока не инвертируется внутри себя: str_fin_mod = substr3_inv + substr2 + substr1_inv

Таким образом, строка, полученная такими преобразованиями из строки 1 2 3 ... N обязана принимать вид исходной 
строки после применения к ней подходящего разбиения на непересекающиеся подстроки, и применения к каждой из них инверсии 0 или 1 раз

Последнее условие эквивалентно тому, что если мы заменим в некоторой подстановке все возрастающие ровно на единицу на каждом шаге 
подпоследовательности на их инверсии, и не получим в итоге возрастающей (всюду ровно на 1) последовательности от N до 1 (1 2 3 ... N), 
то исходная последовательность - это невозможная по нашим правилам подстановка

По построению алгоритма имеем необходимость и достаточность условия убывания любой подпоследовательности не более чем на единицу
